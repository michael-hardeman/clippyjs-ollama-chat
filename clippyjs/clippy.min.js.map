{"version":3,"file":"clippy.min.js","sources":["../lib/queue.js","../lib/animator.js","../lib/balloon.js","../lib/agent.js","../lib/load.js","../lib/index.js"],"sourcesContent":["/**\n * Queue class for managing sequential async operations\n */\nexport default class Queue {\n    /**\n     * @param {Function} onEmptyCallback - Called when queue becomes empty\n     */\n    constructor (onEmptyCallback) {\n        this._queue = [];\n        this._onEmptyCallback = onEmptyCallback;\n    }\n\n    /**\n     * Add a function to the queue\n     * @param {Function} func - Function that receives a completion callback\n     */\n    queue (func) {\n        this._queue.push(func);\n\n        if (this._queue.length === 1 && !this._active) {\n            this._progressQueue();\n        }\n    }\n\n    /**\n     * Process the next item in the queue\n     * @private\n     */\n    _progressQueue () {\n        if (!this._queue.length) {\n            this._onEmptyCallback();\n            return;\n        }\n\n        let f = this._queue.shift();\n        this._active = true;\n\n        let completeFunction = this.next.bind(this);\n        f(completeFunction);\n    }\n\n    /**\n     * Clear all items from the queue\n     */\n    clear () {\n        this._queue = [];\n    }\n\n    /**\n     * Mark current operation as complete and progress to next item\n     */\n    next () {\n        this._active = false;\n        this._progressQueue();\n    }\n}\n","/**\n * Animator class handles frame-by-frame animation playback using sprite sheets\n */\nexport default class Animator {\n    /**\n     * @param {HTMLElement} el - The element to animate\n     * @param {string} path - Path to the agent's asset directory\n     * @param {Object} data - Agent animation data (frames, overlays, sounds)\n     * @param {Object} sounds - Map of sound names to audio URLs\n     */\n    constructor (el, path, data, sounds) {\n        this._el = el;\n        this._data = data;\n        this._path = path;\n        this._currentFrameIndex = 0;\n        this._currentFrame = undefined;\n        this._exiting = false;\n        this._currentAnimation = undefined;\n        this._endCallback = undefined;\n        this._started = false;\n        this._sounds = {};\n        this.currentAnimationName = undefined;\n        this.preloadSounds(sounds);\n        this._overlays = [this._el];\n        let curr = this._el;\n\n        this._setupElement(this._el);\n\n        // Create overlay elements for multi-layer animations\n        for (let i = 1; i < this._data.overlayCount; i++) {\n            let inner = this._setupElement(document.createElement('div'));\n            curr.appendChild(inner);\n            this._overlays.push(inner);\n            curr = inner;\n        }\n    }\n\n    /**\n     * Configure an element for sprite sheet animation\n     * @param {HTMLElement} el - Element to setup\n     * @returns {HTMLElement}\n     * @private\n     */\n    _setupElement (el) {\n        let frameSize = this._data.framesize;\n        el.style.display = 'none';\n        el.style.width = frameSize[0] + 'px';\n        el.style.height = frameSize[1] + 'px';\n        el.style.background = \"url('\" + this._path + \"/map.png') no-repeat\";\n\n        return el;\n    }\n\n    /**\n     * Get list of all available animation names\n     * @returns {string[]}\n     */\n    animations () {\n        let r = [];\n        let d = this._data.animations;\n        for (let n in d) {\n            r.push(n);\n        }\n        return r;\n    }\n\n    /**\n     * Preload audio files for animations\n     * @param {Object} sounds - Map of sound names to URLs\n     */\n    preloadSounds (sounds) {\n        for (let i = 0; i < this._data.sounds.length; i++) {\n            let snd = this._data.sounds[i];\n            let uri = sounds[snd];\n            if (!uri) continue;\n            this._sounds[snd] = new Audio(uri);\n        }\n    }\n\n    /**\n     * Check if an animation exists\n     * @param {string} name - Animation name\n     * @returns {boolean}\n     */\n    hasAnimation (name) {\n        return !!this._data.animations[name];\n    }\n\n    /**\n     * Signal that current animation should exit at next opportunity\n     */\n    exitAnimation () {\n        this._exiting = true;\n    }\n\n    /**\n     * Start playing an animation\n     * @param {string} animationName - Name of the animation to play\n     * @param {Function} stateChangeCallback - Called with (name, state) when animation state changes\n     * @returns {boolean} - True if animation exists and was started\n     */\n    showAnimation (animationName, stateChangeCallback) {\n        this._exiting = false;\n\n        if (!this.hasAnimation(animationName)) {\n            return false;\n        }\n\n        this._currentAnimation = this._data.animations[animationName];\n        this.currentAnimationName = animationName;\n\n        if (!this._started) {\n            this._step();\n            this._started = true;\n        }\n\n        this._currentFrameIndex = 0;\n        this._currentFrame = undefined;\n        this._endCallback = stateChangeCallback;\n\n        return true;\n    }\n\n    /**\n     * Render the current frame by positioning sprite sheet backgrounds\n     * @private\n     */\n    _draw () {\n        let images = [];\n        if (this._currentFrame) images = this._currentFrame.images || [];\n\n        for (let i = 0; i < this._overlays.length; i++) {\n            if (i < images.length) {\n                let xy = images[i];\n                let bg = -xy[0] + 'px ' + -xy[1] + 'px';\n                this._overlays[i].style.backgroundPosition = bg;\n                this._overlays[i].style.display = 'block';\n            }\n            else {\n                this._overlays[i].style.display = 'none';\n            }\n        }\n    }\n\n    /**\n     * Determine the next frame index based on branching logic\n     * @returns {number|undefined}\n     * @private\n     */\n    _getNextAnimationFrame () {\n        if (!this._currentAnimation) return undefined;\n        if (!this._currentFrame) return 0;\n\n        let currentFrame = this._currentFrame;\n        let branching = this._currentFrame.branching;\n\n        // Exit branching takes priority\n        if (this._exiting && currentFrame.exitBranch !== undefined) {\n            return currentFrame.exitBranch;\n        }\n        // Weighted random branching\n        else if (branching) {\n            let rnd = Math.random() * 100;\n            for (let i = 0; i < branching.branches.length; i++) {\n                let branch = branching.branches[i];\n                if (rnd <= branch.weight) {\n                    return branch.frameIndex;\n                }\n                rnd -= branch.weight;\n            }\n        }\n\n        return this._currentFrameIndex + 1;\n    }\n\n    /**\n     * Play the sound associated with the current frame\n     * @private\n     */\n    _playSound () {\n        let s = this._currentFrame.sound;\n        if (!s) return;\n        let audio = this._sounds[s];\n        if (audio) {\n            // Handle autoplay policy - catch and ignore errors when browser blocks autoplay\n            audio.play().catch(() => {\n                // Silently ignore autoplay errors - browser autoplay policy prevents playback\n            });\n        }\n    }\n\n    /**\n     * Check if we're at the last frame of the animation\n     * @returns {boolean}\n     * @private\n     */\n    _atLastFrame () {\n        return this._currentFrameIndex >= this._currentAnimation.frames.length - 1;\n    }\n\n    /**\n     * Advance to the next animation frame\n     * @private\n     */\n    _step () {\n        if (!this._currentAnimation) return;\n\n        let newFrameIndex = Math.min(this._getNextAnimationFrame(), this._currentAnimation.frames.length - 1);\n        let frameChanged = !this._currentFrame || this._currentFrameIndex !== newFrameIndex;\n        this._currentFrameIndex = newFrameIndex;\n\n        // Update frame data unless we're waiting at the last frame with exit branching\n        if (!(this._atLastFrame() && this._currentAnimation.useExitBranching)) {\n            this._currentFrame = this._currentAnimation.frames[this._currentFrameIndex];\n        }\n\n        this._draw();\n        this._playSound();\n\n        this._loop = window.setTimeout(this._step.bind(this), this._currentFrame.duration);\n\n        // Fire callbacks when animation reaches an end state\n        if (this._endCallback && frameChanged && this._atLastFrame()) {\n            if (this._currentAnimation.useExitBranching && !this._exiting) {\n                this._endCallback(this.currentAnimationName, Animator.States.WAITING);\n            }\n            else {\n                this._endCallback(this.currentAnimationName, Animator.States.EXITED);\n            }\n        }\n    }\n\n    /**\n     * Pause animation execution\n     */\n    pause () {\n        window.clearTimeout(this._loop);\n    }\n\n    /**\n     * Resume animation\n     */\n    resume () {\n        this._step();\n    }\n}\n\n/**\n * Animation state constants\n * @enum {number}\n */\nAnimator.States = {\n    WAITING: 1,  // Animation is waiting (e.g., for movement to complete)\n    EXITED: 0    // Animation has completed and exited\n};\n","/**\n * Balloon class for displaying speech bubbles next to the agent\n */\nexport default class Balloon {\n    /**\n     * @param {HTMLElement} targetEl - The agent element to attach the balloon to\n     */\n    constructor (targetEl) {\n        this._targetEl = targetEl;\n        this._hidden = true;\n        this._setup();\n        this.WORD_SPEAK_TIME = 200;\n        this.CLOSE_BALLOON_DELAY = 2000;\n        this._BALLOON_MARGIN = 15;\n    }\n\n    /**\n     * Create and append balloon DOM elements\n     * @private\n     */\n    _setup () {\n        this._balloon = document.createElement('div');\n        this._balloon.className = 'clippy-balloon';\n        this._balloon.style.display = 'none';\n\n        const tip = document.createElement('div');\n        tip.className = 'clippy-tip';\n\n        this._content = document.createElement('div');\n        this._content.className = 'clippy-content';\n\n        this._balloon.appendChild(tip);\n        this._balloon.appendChild(this._content);\n\n        document.body.appendChild(this._balloon);\n    }\n\n    /**\n     * Try different positions to keep balloon on screen\n     */\n    reposition () {\n        let sides = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\n\n        for (let i = 0; i < sides.length; i++) {\n            let s = sides[i];\n            this._position(s);\n            if (!this._isOut()) break;\n        }\n    }\n\n    /**\n     * Position the balloon relative to the agent\n     * @param {string} side - One of: top-left, top-right, bottom-left, bottom-right\n     * @private\n     */\n    _position (side) {\n        let o = this._targetEl.getBoundingClientRect();\n        let h = this._targetEl.offsetHeight;\n        let w = this._targetEl.offsetWidth;\n\n        let bH = this._balloon.offsetHeight;\n        let bW = this._balloon.offsetWidth;\n\n        this._balloon.classList.remove('clippy-top-left', 'clippy-top-right', 'clippy-bottom-right', 'clippy-bottom-left');\n\n        let left, top;\n        switch (side) {\n            case 'top-left':\n                left = o.left + w - bW;\n                top = o.top - bH - this._BALLOON_MARGIN;\n                break;\n            case 'top-right':\n                left = o.left;\n                top = o.top - bH - this._BALLOON_MARGIN;\n                break;\n            case 'bottom-right':\n                left = o.left;\n                top = o.top + h + this._BALLOON_MARGIN;\n                break;\n            case 'bottom-left':\n                left = o.left + w - bW;\n                top = o.top + h + this._BALLOON_MARGIN;\n                break;\n        }\n\n        this._balloon.style.top = top + 'px';\n        this._balloon.style.left = left + 'px';\n        this._balloon.classList.add('clippy-' + side);\n    }\n\n    /**\n     * Check if balloon is positioned outside the viewport\n     * @returns {boolean}\n     * @private\n     */\n    _isOut () {\n        let o = this._balloon.getBoundingClientRect();\n        let bH = this._balloon.offsetHeight;\n        let bW = this._balloon.offsetWidth;\n\n        let wW = window.innerWidth;\n        let wH = window.innerHeight;\n\n        let top = o.top;\n        let left = o.left;\n        let m = 5;\n        if (top - m < 0 || left - m < 0) return true;\n        return (top + bH + m) > wH || (left + bW + m) > wW;\n    }\n\n    /**\n     * Display text in the balloon with typewriter effect\n     * @param {Function} complete - Callback when speaking is done\n     * @param {string} text - Text to display\n     * @param {boolean} hold - If true, keep balloon open after speaking\n     */\n    speak (complete, text, hold) {\n        this._hidden = false;\n        this.show();\n        let c = this._content;\n\n        // Measure the text dimensions by temporarily setting it\n        c.style.height = 'auto';\n        c.style.width = 'auto';\n        c.textContent = text;\n        c.style.height = c.offsetHeight + 'px';\n        c.style.width = c.offsetWidth + 'px';\n        c.textContent = '';\n        this.reposition();\n\n        this._complete = complete;\n        this._sayWords(text, hold, complete);\n    }\n\n    /**\n     * Show the balloon\n     */\n    show () {\n        if (this._hidden) return;\n        this._balloon.style.display = 'block';\n    }\n\n    /**\n     * Hide the balloon\n     * @param {boolean} fast - If true, hide immediately without delay\n     */\n    hide (fast) {\n        if (fast) {\n            this._balloon.style.display = 'none';\n            return;\n        }\n\n        this._hiding = window.setTimeout(this._finishHideBalloon.bind(this), this.CLOSE_BALLOON_DELAY);\n    }\n\n    /**\n     * Complete the hide operation\n     * @private\n     */\n    _finishHideBalloon () {\n        if (this._active) return;\n        this._balloon.style.display = 'none';\n        this._hidden = true;\n        this._hiding = null;\n    }\n\n    /**\n     * Animate text appearing word by word\n     * @param {string} text - Text to animate\n     * @param {boolean} hold - If true, keep balloon open after speaking\n     * @param {Function} complete - Callback when animation is done\n     * @private\n     */\n    _sayWords (text, hold, complete) {\n        this._active = true;\n        this._hold = hold;\n        let words = text.split(/[^\\S-]/);\n        let time = this.WORD_SPEAK_TIME;\n        let el = this._content;\n        let idx = 1;\n\n        this._addWord = () => {\n            if (!this._active) return;\n            if (idx > words.length) {\n                delete this._addWord;\n                this._active = false;\n                if (!this._hold) {\n                    complete();\n                    this.hide();\n                }\n            } else {\n                el.textContent = words.slice(0, idx).join(' ');\n                idx++;\n                this._loop = window.setTimeout(this._addWord, time);\n            }\n        };\n\n        this._addWord();\n    }\n\n    /**\n     * Close the balloon and trigger completion callback if held\n     */\n    close () {\n        if (this._active) {\n            this._hold = false;\n        } else if (this._hold) {\n            this._complete();\n        }\n    }\n\n    /**\n     * Pause the balloon animation and hide timer\n     */\n    pause () {\n        window.clearTimeout(this._loop);\n        if (this._hiding) {\n            window.clearTimeout(this._hiding);\n            this._hiding = null;\n        }\n    }\n\n    /**\n     * Resume the balloon animation or hide timer\n     */\n    resume () {\n        if (this._addWord) {\n            this._addWord();\n        } else if (!this._hold && !this._hidden) {\n            this._hiding = window.setTimeout(this._finishHideBalloon.bind(this), this.CLOSE_BALLOON_DELAY);\n        }\n    }\n}\n","import Queue from './queue'\nimport Animator from './animator'\nimport Balloon from './balloon'\n\n/**\n * Agent class represents an animated character that can move, speak, and perform actions\n */\nexport default class Agent {\n    /**\n     * @param {string} path - Path to the agent's asset directory\n     * @param {Object} data - Agent animation data\n     * @param {Object} sounds - Map of sound names to audio URLs\n     */\n    constructor (path, data, sounds) {\n        this.path = path;\n\n        this._queue = new Queue(this._onQueueEmpty.bind(this));\n\n        this._el = document.createElement('div');\n        this._el.className = 'clippy';\n        this._el.style.display = 'none';\n\n        document.body.appendChild(this._el);\n\n        this._animator = new Animator(this._el, path, data, sounds);\n        this._balloon = new Balloon(this._el);\n\n        this._setupEvents();\n    }\n\n    /**\n     * Make the agent gesture towards a specific point\n     * @param {number} x - X coordinate\n     * @param {number} y - Y coordinate\n     * @returns {boolean} - True if gesture animation was played\n     */\n    gestureAt (x, y) {\n        let d = this._getDirection(x, y);\n        let gAnim = 'Gesture' + d;\n        let lookAnim = 'Look' + d;\n\n        let animation = this.hasAnimation(gAnim) ? gAnim : lookAnim;\n        return this.play(animation);\n    }\n\n    /**\n     * Hide the agent\n     * @param {boolean} [fast] - If true, hide immediately without animation\n     * @param {Function} [callback] - Called when hide is complete\n     */\n    hide (fast, callback) {\n        this._hidden = true;\n        let el = this._el;\n        this.stop();\n        if (fast) {\n            this._el.style.display = 'none';\n            this.stop();\n            this.pause();\n            if (callback) callback();\n            return;\n        }\n\n        return this._playInternal('Hide', function () {\n            el.style.display = 'none';\n            this.pause();\n            if (callback) callback();\n        })\n    }\n\n    /**\n     * Move the agent to a specific position\n     * @param {number} x - Target X coordinate\n     * @param {number} y - Target Y coordinate\n     * @param {number} [duration=1000] - Movement duration in milliseconds\n     */\n    moveTo (x, y, duration) {\n        let dir = this._getDirection(x, y);\n        let anim = 'Move' + dir;\n        if (duration === undefined) duration = 1000;\n\n        this._addToQueue(function (complete) {\n            if (duration === 0) {\n                this._el.style.top = y + 'px';\n                this._el.style.left = x + 'px';\n                this.reposition();\n                complete();\n                return;\n            }\n\n            if (!this.hasAnimation(anim)) {\n                this._animate(this._el, { top: y, left: x }, duration, complete);\n                return;\n            }\n\n            let callback = (name, state) => {\n                if (state === Animator.States.EXITED) {\n                    complete();\n                }\n                if (state === Animator.States.WAITING) {\n                    this._animate(this._el, { top: y, left: x }, duration, () => {\n                        this._animator.exitAnimation();\n                    });\n                }\n            };\n\n            this._playInternal(anim, callback);\n        }, this);\n    }\n\n    /**\n     * Animate element properties over time using requestAnimationFrame\n     * @param {HTMLElement} element - Element to animate\n     * @param {Object} props - Properties to animate (e.g., {top: 100, left: 200})\n     * @param {number} duration - Animation duration in milliseconds\n     * @param {Function} [callback] - Called when animation completes\n     * @private\n     */\n    _animate(element, props, duration, callback) {\n        const start = performance.now();\n        const startProps = {};\n\n        for (let prop in props) {\n            const currentValue = parseFloat(getComputedStyle(element)[prop]) || 0;\n            startProps[prop] = currentValue;\n        }\n\n        // jQuery swing easing: ease-in-out\n        const swing = (p) => 0.5 - Math.cos(p * Math.PI) / 2;\n\n        const animate = (currentTime) => {\n            const elapsed = currentTime - start;\n            const progress = Math.min(elapsed / duration, 1);\n            const eased = swing(progress);\n\n            for (let prop in props) {\n                const startValue = startProps[prop];\n                const endValue = props[prop];\n                const currentValue = startValue + (endValue - startValue) * eased;\n                element.style[prop] = currentValue + 'px';\n            }\n\n            if (progress < 1) {\n                requestAnimationFrame(animate);\n            } else if (callback) {\n                callback();\n            }\n        };\n\n        requestAnimationFrame(animate);\n    }\n\n    /**\n     * Internal animation playback that handles idle animation interruption\n     * @param {string} animation - Animation name\n     * @param {Function} callback - State change callback\n     * @private\n     */\n    _playInternal (animation, callback) {\n        // Wait for idle animation to complete before starting new animation\n        if (this._isIdleAnimation() && this._idlePromise) {\n            this._idlePromise.then(() => {\n                this._playInternal(animation, callback);\n            });\n            return;\n        }\n\n        this._animator.showAnimation(animation, callback);\n    }\n\n    /**\n     * Play a named animation\n     * @param {string} animation - Animation name\n     * @param {number} [timeout=5000] - Timeout in milliseconds before auto-exiting\n     * @param {Function} [cb] - Callback when animation completes\n     * @returns {boolean} - True if animation exists and was queued\n     */\n    play (animation, timeout, cb) {\n        if (!this.hasAnimation(animation)) return false;\n\n        if (timeout === undefined) timeout = 5000;\n\n        this._addToQueue(function (complete) {\n            let completed = false;\n\n            let callback = function (name, state) {\n                if (state === Animator.States.EXITED) {\n                    completed = true;\n                    if (cb) cb();\n                    complete();\n                }\n            };\n\n            if (timeout) {\n                window.setTimeout(() => {\n                    if (completed) return;\n                    this._animator.exitAnimation();\n                }, timeout)\n            }\n\n            this._playInternal(animation, callback);\n        }, this);\n\n        return true;\n    }\n\n    /**\n     * Show the agent\n     * @param {boolean} [fast] - If true, show immediately without animation\n     */\n    show (fast) {\n        this._hidden = false;\n        if (fast) {\n            this._el.style.display = 'block';\n            this.resume();\n            this._onQueueEmpty();\n            return;\n        }\n\n        const style = getComputedStyle(this._el);\n\n        if (style.top === 'auto' || style.left === 'auto') {\n            let left = window.innerWidth * 0.8;\n            let top = (window.innerHeight + window.pageYOffset) * 0.8;\n            this._el.style.top = top + 'px';\n            this._el.style.left = left + 'px';\n        }\n\n        this.resume();\n        return this.play('Show');\n    }\n\n    /**\n     * Make the agent speak text in a speech balloon\n     * @param {string} text - Text to display\n     * @param {boolean} [hold] - If true, keep balloon open until manually closed\n     */\n    speak (text, hold) {\n        this._addToQueue(function (complete) {\n            this._balloon.speak(complete, text, hold);\n        }, this);\n    }\n\n    /**\n     * Close the current speech balloon\n     */\n    closeBalloon () {\n        this._balloon.hide();\n    }\n\n    /**\n     * Add a delay to the action queue\n     * @param {number} [time=250] - Delay in milliseconds\n     */\n    delay (time) {\n        time = time || 250;\n\n        this._addToQueue(function (complete) {\n            this._onQueueEmpty();\n            window.setTimeout(complete, time);\n        });\n    }\n\n    /**\n     * Skip the current animation\n     */\n    stopCurrent () {\n        this._animator.exitAnimation();\n        this._balloon.close();\n    }\n\n    /**\n     * Stop all animations and clear the queue\n     */\n    stop () {\n        this._queue.clear();\n        this._animator.exitAnimation();\n        this._balloon.hide();\n    }\n\n    /**\n     * Check if an animation exists\n     * @param {string} name - Animation name\n     * @returns {boolean}\n     */\n    hasAnimation (name) {\n        return this._animator.hasAnimation(name);\n    }\n\n    /**\n     * Get list of all available animations\n     * @returns {string[]}\n     */\n    animations () {\n        return this._animator.animations();\n    }\n\n    /**\n     * Play a random non-idle animation\n     * @returns {boolean}\n     */\n    animate () {\n        let animations = this.animations();\n        let anim = animations[Math.floor(Math.random() * animations.length)];\n\n        if (anim.indexOf('Idle') === 0) {\n            return this.animate();\n        }\n        return this.play(anim);\n    }\n\n    /**\n     * Calculate direction from agent to a point\n     * @param {number} x - Target X coordinate\n     * @param {number} y - Target Y coordinate\n     * @returns {string} - Direction: 'Up', 'Down', 'Left', 'Right', or 'Top'\n     * @private\n     */\n    _getDirection (x, y) {\n        let rect = this._el.getBoundingClientRect();\n        let h = this._el.offsetHeight;\n        let w = this._el.offsetWidth;\n\n        let centerX = (rect.left + w / 2);\n        let centerY = (rect.top + h / 2);\n\n        let a = centerY - y;\n        let b = centerX - x;\n\n        let r = Math.round((180 * Math.atan2(a, b)) / Math.PI);\n\n        // Note: Left and Right are from the character's perspective\n        if (-45 <= r && r < 45) return 'Right';\n        if (45 <= r && r < 135) return 'Up';\n        if (135 <= r && r <= 180 || -180 <= r && r < -135) return 'Left';\n        if (-135 <= r && r < -45) return 'Down';\n\n        return 'Top';\n    }\n\n    /**\n     * Handle empty queue by transitioning to idle animation\n     * @private\n     */\n    _onQueueEmpty () {\n        if (this._hidden || this._isIdleAnimation()) return;\n\n        let idleAnim = this._getIdleAnimation();\n        this._idlePromise = new Promise(resolve => {\n            this._idleResolve = resolve;\n        });\n\n        this._animator.showAnimation(idleAnim, this._onIdleComplete.bind(this));\n    }\n\n\n    /**\n     * Handle idle animation completion\n     * @param {string} name - Animation name\n     * @param {number} state - Animation state\n     * @private\n     */\n    _onIdleComplete (name, state) {\n        if (state === Animator.States.EXITED) {\n            if (this._idleResolve) {\n                this._idleResolve();\n            }\n            this._idlePromise = null;\n            this._idleResolve = null;\n        }\n    }\n\n    /**\n     * Check if currently playing an idle animation\n     * @returns {boolean}\n     * @private\n     */\n    _isIdleAnimation () {\n        let c = this._animator.currentAnimationName;\n        return c && c.indexOf('Idle') === 0;\n    }\n\n    /**\n     * Get a random idle animation name\n     * @returns {string}\n     * @private\n     */\n    _getIdleAnimation () {\n        let animations = this.animations();\n        let r = [];\n        for (let i = 0; i < animations.length; i++) {\n            let a = animations[i];\n            if (a.indexOf('Idle') === 0) {\n                r.push(a);\n            }\n        }\n\n        let idx = Math.floor(Math.random() * r.length);\n        return r[idx];\n    }\n\n    /**\n     * Setup event listeners for resizing and interaction\n     * @private\n     */\n    _setupEvents () {\n        window.addEventListener('resize', this.reposition.bind(this));\n        this._el.addEventListener('mousedown', this._onMouseDown.bind(this));\n        this._el.addEventListener('dblclick', this._onDoubleClick.bind(this));\n    }\n\n    /**\n     * Handle double-click to trigger ClickedOn animation or random animation\n     * @private\n     */\n    _onDoubleClick () {\n        if (!this.play('ClickedOn')) {\n            this.animate();\n        }\n    }\n\n    /**\n     * Reposition agent to stay within viewport bounds\n     */\n    reposition () {\n        const style = getComputedStyle(this._el);\n        if (style.display === 'none') return;\n        if (style.visibility === 'hidden') return;\n        if (style.width === '0' || style.height === '0') return;\n\n        let o = this._el.getBoundingClientRect();\n        let bH = this._el.offsetHeight;\n        let bW = this._el.offsetWidth;\n\n        let wW = window.innerWidth;\n        let wH = window.innerHeight;\n\n        let top = o.top;\n        let left = o.left;\n        let m = 5;\n\n        if (top - m < 0) {\n            top = m;\n        } else if ((top + bH + m) > wH) {\n            top = wH - bH - m;\n        }\n\n        if (left - m < 0) {\n            left = m;\n        } else if (left + bW + m > wW) {\n            left = wW - bW - m;\n        }\n\n        this._el.style.left = left + 'px';\n        this._el.style.top = top + 'px';\n        this._balloon.reposition();\n    }\n\n    /**\n     * Handle mouse down to start dragging\n     * @param {MouseEvent} e\n     * @private\n     */\n    _onMouseDown (e) {\n        e.preventDefault();\n        this._startDrag(e);\n    }\n\n    /**\n     * Initialize drag operation\n     * @param {MouseEvent} e\n     * @private\n     */\n    _startDrag (e) {\n        this.pause();\n        this._balloon.hide(true);\n        this._offset = this._calculateClickOffset(e);\n\n        this._moveHandle = this._dragMove.bind(this);\n        this._upHandle = this._finishDrag.bind(this);\n\n        window.addEventListener('mousemove', this._moveHandle);\n        window.addEventListener('mouseup', this._upHandle);\n\n        this._dragUpdateLoop = window.setTimeout(this._updateLocation.bind(this), 10);\n    }\n\n    /**\n     * Calculate offset between click position and agent position\n     * @param {MouseEvent} e\n     * @returns {{top: number, left: number}}\n     * @private\n     */\n    _calculateClickOffset (e) {\n        let mouseX = e.pageX;\n        let mouseY = e.pageY;\n        let o = this._el.getBoundingClientRect();\n        return {\n            top: mouseY - (o.top + window.pageYOffset),\n            left: mouseX - (o.left + window.pageXOffset)\n        }\n    }\n\n    /**\n     * Update agent position during drag\n     * @private\n     */\n    _updateLocation () {\n        this._el.style.top = this._targetY + 'px';\n        this._el.style.left = this._targetX + 'px';\n        this._dragUpdateLoop = window.setTimeout(this._updateLocation.bind(this), 10);\n    }\n\n    /**\n     * Handle mouse move during drag\n     * @param {MouseEvent} e\n     * @private\n     */\n    _dragMove (e) {\n        e.preventDefault();\n        let x = e.clientX - this._offset.left;\n        let y = e.clientY - this._offset.top;\n        this._targetX = x;\n        this._targetY = y;\n    }\n\n    /**\n     * Complete drag operation\n     * @private\n     */\n    _finishDrag () {\n        window.clearTimeout(this._dragUpdateLoop);\n        window.removeEventListener('mousemove', this._moveHandle);\n        window.removeEventListener('mouseup', this._upHandle);\n\n        this._balloon.show();\n        this.reposition();\n        this.resume();\n    }\n\n    /**\n     * Add a function to the action queue\n     * @param {Function} func - Function to queue\n     * @param {Object} [scope] - Scope to bind function to\n     * @private\n     */\n    _addToQueue (func, scope) {\n        if (scope) func = func.bind(scope);\n        this._queue.queue(func);\n    }\n\n    /**\n     * Pause animations and balloon\n     */\n    pause () {\n        this._animator.pause();\n        this._balloon.pause();\n    }\n\n    /**\n     * Resume animations and balloon\n     */\n    resume () {\n        this._animator.resume();\n        this._balloon.resume();\n    }\n}\n","import Agent from './agent'\n\n// Cache for loaded resources\nconst _maps = {};\nconst _sounds = {};\nconst _data = {};\nconst _dataCallbacks = {};\nconst _soundsCallbacks = {};\n\n/**\n * Load a sprite sheet map image\n * @param {string} path - Path to agent directory\n * @returns {Promise} - Resolves when image is loaded\n * @private\n */\nfunction _loadMap(path) {\n    let dfd = _maps[path];\n    if (dfd) return dfd;\n\n    dfd = _maps[path] = new Promise((resolve, reject) => {\n        let src = path + '/map.png';\n        let img = new Image();\n\n        img.onload = resolve;\n        img.onerror = reject;\n\n        img.setAttribute('src', src);\n    });\n\n    return dfd;\n}\n\n/**\n * Load sound files for an agent\n * @param {string} name - Agent name\n * @param {string} path - Path to agent directory\n * @returns {Promise<Object>} - Resolves with sound map or empty object\n * @private\n */\nfunction _loadSounds(name, path) {\n    let dfd = _sounds[name];\n    if (dfd) return dfd;\n\n    dfd = _sounds[name] = new Promise((resolve, reject) => {\n        let audio = document.createElement('audio');\n        let canPlayMp3 = !!audio.canPlayType && \"\" !== audio.canPlayType('audio/mpeg');\n        let canPlayOgg = !!audio.canPlayType && \"\" !== audio.canPlayType('audio/ogg; codecs=\"vorbis\"');\n\n        if (!canPlayMp3 && !canPlayOgg) {\n            resolve({});\n        } else {\n            let src = path + (canPlayMp3 ? '/sounds-mp3.js' : '/sounds-ogg.js');\n            _soundsCallbacks[name] = { resolve, reject };\n            _loadScript(src);\n        }\n    });\n\n    return dfd;\n}\n\n/**\n * Load agent animation data\n * @param {string} name - Agent name\n * @param {string} path - Path to agent directory\n * @returns {Promise<Object>} - Resolves with agent data\n * @private\n */\nfunction _loadAgent(name, path) {\n    let dfd = _data[name];\n    if (dfd) return dfd;\n\n    dfd = _data[name] = new Promise((resolve, reject) => {\n        _dataCallbacks[name] = { resolve, reject };\n    });\n\n    let src = path + '/agent.js';\n    _loadScript(src);\n\n    return dfd;\n}\n\n/**\n * Dynamically load a script file\n * @param {string} src - Script URL\n * @private\n */\nfunction _loadScript(src) {\n    let script = document.createElement('script');\n    script.setAttribute('src', src);\n    script.setAttribute('async', 'async');\n    script.setAttribute('type', 'text/javascript');\n\n    document.head.appendChild(script);\n}\n\n/**\n * Load an agent with all its assets\n * @param {string} name - Agent name (e.g., 'Clippy', 'Merlin')\n * @param {Function} successCb - Called with initialized Agent instance\n * @param {Function} [failCb] - Called if loading fails\n * @param {string} [base_path] - Custom base path for agent assets\n */\nexport function load(name, successCb, failCb, base_path) {\n    base_path = base_path || window.CLIPPY_CDN || 'https://cdn.jsdelivr.net/gh/pi0/clippyjs@master/assets/agents/'\n\n    let path = base_path + name;\n    let mapDfd = _loadMap(path);\n    let agentDfd = _loadAgent(name, path);\n    let soundsDfd = _loadSounds(name, path);\n\n    let data;\n    agentDfd.then(function (d) {\n        data = d;\n    });\n\n    let sounds;\n    soundsDfd.then(function (d) {\n        sounds = d;\n    });\n\n    let cb = function () {\n        let a = new Agent(path, data, sounds);\n        successCb(a);\n    };\n\n    Promise.all([mapDfd, agentDfd, soundsDfd]).then(cb).catch(failCb);\n}\n\n/**\n * Called by agent.js files to register agent data\n * This function is called by dynamically loaded agent scripts\n * @param {string} name - Agent name\n * @param {Object} data - Agent animation data\n */\nexport function ready(name, data) {\n    let callbacks = _dataCallbacks[name];\n    if (callbacks && callbacks.resolve) {\n        callbacks.resolve(data);\n    }\n}\n\n/**\n * Called by sound files to register sound data\n * This function is called by dynamically loaded sound scripts\n * @param {string} name - Agent name\n * @param {Object} data - Sound URL mappings\n */\nexport function soundsReady(name, data) {\n    let callbacks = _soundsCallbacks[name];\n    if (callbacks && callbacks.resolve) {\n        callbacks.resolve(data);\n    }\n}\n","import Agent from './agent'\nimport Animator from './animator'\nimport Queue from './queue'\nimport Balloon from './balloon'\nimport { load, ready, soundsReady } from './load'\n\nconst clippy = {\n    Agent,\n    Animator,\n    Queue,\n    Balloon,\n    load,\n    ready,\n    soundsReady\n}\n\nexport default clippy\n\nif (typeof window !== 'undefined') {\n    window.clippy = clippy\n}\n"],"names":["Queue","constructor","onEmptyCallback","this","_queue","_onEmptyCallback","queue","func","push","length","_active","_progressQueue","f","shift","next","bind","clear","Animator","el","path","data","sounds","_el","_data","_path","_currentFrameIndex","_currentFrame","undefined","_exiting","_currentAnimation","_endCallback","_started","_sounds","currentAnimationName","preloadSounds","_overlays","curr","_setupElement","i","overlayCount","inner","document","createElement","appendChild","frameSize","framesize","style","display","width","height","background","animations","r","d","n","snd","uri","Audio","hasAnimation","name","exitAnimation","showAnimation","animationName","stateChangeCallback","_step","_draw","images","xy","bg","backgroundPosition","_getNextAnimationFrame","currentFrame","branching","exitBranch","rnd","Math","random","branches","branch","weight","frameIndex","_playSound","s","sound","audio","play","catch","_atLastFrame","frames","newFrameIndex","min","frameChanged","useExitBranching","_loop","window","setTimeout","duration","States","WAITING","EXITED","pause","clearTimeout","resume","Balloon","targetEl","_targetEl","_hidden","_setup","WORD_SPEAK_TIME","CLOSE_BALLOON_DELAY","_BALLOON_MARGIN","_balloon","className","tip","_content","body","reposition","sides","_position","_isOut","side","left","top","o","getBoundingClientRect","h","offsetHeight","w","offsetWidth","bH","bW","classList","remove","add","wW","innerWidth","wH","innerHeight","speak","complete","text","hold","show","c","textContent","_complete","_sayWords","hide","fast","_hiding","_finishHideBalloon","_hold","words","split","time","idx","_addWord","slice","join","close","Agent","_onQueueEmpty","_animator","_setupEvents","gestureAt","x","y","_getDirection","gAnim","lookAnim","animation","callback","stop","_playInternal","moveTo","anim","_addToQueue","_animate","state","element","props","start","performance","now","startProps","prop","currentValue","parseFloat","getComputedStyle","animate","currentTime","elapsed","progress","eased","p","cos","PI","startValue","requestAnimationFrame","_isIdleAnimation","_idlePromise","then","timeout","cb","completed","pageYOffset","closeBalloon","delay","stopCurrent","floor","indexOf","rect","centerX","a","b","round","atan2","idleAnim","_getIdleAnimation","Promise","resolve","_idleResolve","_onIdleComplete","addEventListener","_onMouseDown","_onDoubleClick","visibility","e","preventDefault","_startDrag","_offset","_calculateClickOffset","_moveHandle","_dragMove","_upHandle","_finishDrag","_dragUpdateLoop","_updateLocation","mouseX","pageX","mouseY","pageY","pageXOffset","_targetY","_targetX","clientX","clientY","removeEventListener","scope","_maps","_dataCallbacks","_soundsCallbacks","_loadScript","src","script","setAttribute","head","clippy","load","successCb","failCb","base_path","CLIPPY_CDN","mapDfd","dfd","reject","img","Image","onload","onerror","_loadMap","agentDfd","_loadAgent","soundsDfd","canPlayMp3","canPlayType","canPlayOgg","_loadSounds","all","ready","callbacks","soundsReady"],"mappings":"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"}